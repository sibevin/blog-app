.meta-data title Metaprogramming Ruby 2 - ch1 - The Object Model
.meta-data datetime 2016-04-10 13:43:13
.meta-data tags mp,mr2,note,ruby
.meta-data category coding
.meta-data link mr2-ch2-the-object-model
.meta-data file 2016-04-10-134313-mr2-ch2-the-object-model
.meta-data template post

.meta-data end

h1 前言

p 這是 Metaprogramming Ruby 2 的閱讀筆記，只會記錄我覺得重要的地方。如果你想要了解完整的內容或是想讓Ruby程式做一些神奇的事，強烈推薦去讀讀這本書。

h1 Open Classes

p 
  span.mk-blue Open Class
  | ：我們可以在任何時間點reopen已經存在的class並修改它。

pre
  code.ruby
    | class A
        def say_hi
          puts "Hi"
        end
      end

      a = A.new
      a.say_hi # Hi
      # a.say_hello # NoMethodError

      class A
        def say_hello
          puts "Hello"
        end
      end

      a.say_hi # Hi
      a.say_hello # Hello

p 上面的例子，第二個class A並不是重新定義class A，而是reopen class A，並加一個新的method在class A之中。有趣的是即使是在reopen之前宣告的instance a，在reopen加上method之後就會有新的method可以用。

h1 The Problem with Open Classes

pre
  code.ruby
    | class A
        def say_hi
          puts "Hi"
        end
      end

      a = A.new
      a.say_hi # Hi

      class A
        def say_hi
          puts "Hi,Hi~"
        end
      end

      a.say_hi # Hi,Hi~

p 
  | 由上面的例子可以發現reopen之後我們可以將原本存在在class的method履寫掉，這樣的特性會在使用open class時很容易不小心改掉class原本的method而造成非預期的bug，所以這個技巧又被稱做
  span.mk-blue Monkeypatch
  | 。

h1 Inside the Object Model

pre
  code.ruby
    | class A
        def say_hi
          @var = 1
          puts "Hi"
        end
      end
      
      a = A.new

      p a.class # A
      p a.methods # [:say_hi, ... ]
      p a.instance_variable # []
      
      a.say_hi # Hi
      
      p a.instance_variable # [:@var]

      p A.class # Class
      p A.instance_methods # [:say_hi, ... ]
      p A.superclass # Object

      p Class.class # Class
      p Class.superclass # Module
      p Class.instance_methods # [:new, ... ]

      p Module.superclass # Object

      p Object.superclass # BasicObject

      p BasicObject.superclass # nil

p a, A, Class, Module, Object, BasicObject之間的關係可以從下圖了解：

.image-center
  a href="/images/post/20160410155612-mr2-ch2-object-model.png"
    img src="/images/post/20160410155612-mr2-ch2-object-model.png" alt="ruby 物件關係圖"
  .image-text
    | ruby 物件關係圖
    
h2 Instance Variables

p @var是a的一個instance variable，instance variable是在instance a中定義的，跟A一點關係也沒有，也就是即使是同一個class的instance，也可以有完全不同的instance variable。另外從上面的例子可以知道@var是在say_hi被呼叫之後才被定義，也就是instance variable是可以動態被建立的，而不是預先定義。

h2 Methods

p say_hi是A的一個instance method，instance method是定義在A中，但只有A的instance a才可以呼叫。你會發現a.methods與A.instance_methods列出來的結果是一樣的(在沒有include其它module的情況下)，也就是instance method是定義在A中，而每一個instance都會共用相同的instance methods。

h2 Modules
  
p Class繼承Module表示每一個Class都是一個Module，不過在使用上我們會做區分，module表示會被include在其它的地方，而class會用來做instance或是建立繼承體系。

h2 Constants

p 在ruby中會把class或是module的命名稱做constants，它們都會是大寫字母開頭。Constants在ruby中是可以被變更的(書上舉Rake的例子還蠻有趣的)，與變數不同的是它有namespace的概念。

pre
  code.ruby
    | A = "A root-level constant"

      module B
        class C
          A = "A constant in a class"

          def self.get_class_a
            A
          end

          def self.get_root_a
            ::A
          end

          def self.show_nesting
            Module.nesting
          end
        end

        def self.show_nesting
          Module.nesting
        end
      end

      p A # "A root-level constant"
      p B::C::A # "A constant in a class"

      p B::C.get_class_a # "A constant in a class"
      p B::C.get_root_a # "A root-level constant"

      p B.constants # [:C]
      p B::C.constants # [:A]
      p Module.constants # [:A, :B, :Object, :Module, :Class, :BasicObject, :Kernel, ... ]

      p B.show_nesting # [B]
      p B::C.show_nesting # [B::C, B]

ul
  li class或是module的命名我們會使用pascal cased，例如
    code
      | 。
  li 可以使用::來取得root的constants，例如上面的 
    code
      | ::A
    | 。
  li 
    code
      | Module.constant
    | 會列出所有root-level的constants。 
    code
      | Module.nesting
    | 則可以列出目前的namespace。

h2 Loading and Requiring
i
  | a.rb
pre
  code.ruby
    | A = "A constant in a.rb"

    = "\n" + 'p "Print A = \'#{A}\' in a.rb"'
      
i
  | b.rb
pre
  code.ruby
    | A = "A constant in b.rb"

    = "\n" + 'p "Print A = \'#{A}\' in b.rb"'

p 如果在c.rb裡同時load a.rb與b.rb兩個檔案如下：

i
  | c.rb
pre
  code.ruby
    | load("a.rb")
      load("b.rb")

    = "\n" + 'p "Print A = \'#{A}\' in c.rb"' + "\n"
      
    | load("b.rb")
      
p 則會出現下面的結果：

pre
  code.nohighlight
    | "Print A = 'A constant in file a.rb' in a.rb"
      b.rb:1: warning: already initialized constant A
      a.rb:1: warning: previous definition of A was here
      "Print A = 'A constant in file b.rb' in b.rb"
      "Print A = 'A constant in file b.rb' in c.rb"
      b.rb:1: warning: already initialized constant A
      b.rb:1: warning: previous definition of A was here
      "Print A = 'A constant in file b.rb' in b.rb"
      
p 由此可知，使用load有下面特性：
ul
  li 被load的檔案會被執行(print有被執行)。
  li 如果load的兩個檔案裡有相同的constant，則會出現警告，而且會以最後載入的constant為主。
  li 如果重複load相同的檔案，則檔案會被重複執行。

p 如果不想將b.rb裡的constant載入到c.rb中，則可以在load後面加上true：
i
  | c.rb
pre
  code.ruby
    | load("a.rb")
      load("b.rb", true)

    = "\n" + 'p "Print A = \'#{A}\' in c.rb"'
pre
  code.nohighlight
    | "Print A = 'A constant in file a.rb' in a.rb"
      "Print A = 'A constant in file b.rb' in b.rb"
      "Print A = 'A constant in file a.rb' in c.rb"
p 上面執行的結果就只會讀到a.rb的A，但b.rb的程式碼仍會執行。

p 如果將c.rb改成require如下：
pre
  code.ruby
    | require("./a")
      require("./b")

    = "\n" + 'p "Print A = \'#{A}\' in c.rb"' + "\n"

    | require("./b")
p 則結果會變成：
pre
  code.nohighlight
    | "Print A = 'A constant in file a.rb' in a.rb"
      /Users/kait/temp/b.rb:1: warning: already initialized constant A
      /Users/kait/temp/a.rb:1: warning: previous definition of A was here
      "Print A = 'A constant in file b.rb' in b.rb"
      "Print A = 'A constant in file b.rb' in c.rb"
p 由此可知，require與load的差別在於
ul
  li require需要指定絕對路徑(更精確來說，如果不指定絕對路徑，則預設會去找$LOAD_PATH目錄裡有沒有指定的檔案，範例是將a.rb, b.rb, c.rb放在同一個目錄下，而./並不在預設的$LOAD_PATH，所以不加./會找不到)
  li require可以省略檔案的副檔名.rb，但load則是一定要加.rb，不然會找不到檔案。
  li 如果require兩次相同的檔案，則檔案只會載入並執行第一次，之後的不會重複載入執行，load則每次都會載入執行。
    
h1 What Happens When You Call a Method?

h2 Method Lookup

pre
  code.ruby
    | class A
        def say_hi
          puts "Hi"
        end
      end
      
      class B < A
      end
      
      b = B.new
      b.say_hi # Hi
      B.ancestors # [B, A, Object, Kernel, BasicObject]

p
  | instance b呼叫了say_hi，這時候ruby會先去找對應這個instance的class，也就是B有沒有定義這個method，如果沒有則往繼承體系上找有沒有這個method，以上面的例子而言，在class A中找到了say_hi，於是就會使用class A中定義的say_hi。我們可以使用 
  code
    | ancestors
  | 來查看一個class它所對應的繼承體系。

h2 Modules and Lookup

p
  | 當module被include或是prepend時，module也會被加入到class的繼承體系中，如果module中有相同的method則會根據繼承體系中最先找到的method當作定義。
  
pre
  code.ruby
    | class A
        def say_hi
          "Hi in A"
        end
      end

      class B < A
        def say_hi
          "Hi in B"
        end
      end

      module M1
        def say_hi
          "Hi in M1"
        end
      end

      module M2
        def say_hi
          "Hi in M2"
        end
      end

      class C < B
        include M1
        prepend M2
        def say_hi
          "Hi in C"
        end
      end

      c = C.new
      p c.say_hi # "Hi in M2"
      p C.ancestors # [M2, C, M1, B, A, Object, Kernel, BasicObject]

h2 The Kernel

p 
  span.mk-blue Kernel Method
  | ：因為Object有include Kernel module，因此ruby中所有的物件都可以使用Kernel內定義的method。換句話說，只要將method加入Kernel中，則所有的物件都會擁有這個method，這會讓method變成像是ruby keyword的錯覺，酷。
  
pre
  code.ruby
    | module Kernel
        def say_hi
          "Hi"
        end
      end

      p say_hi

      class A
      end

      a = A.new
      p a.say_hi

p 
  | 上面的例子，我們用
  span.mk-blue Open Class
  | 的方式將say_hi塞到Kernel中，這時候say_hi變成到處都可以用了。書上也舉了AwesomePrint這個有趣的例子。
  
h2 Method Execution

p 
  | ruby的每一行程式碼都是在某個物件中執行，我們稱做current object，而ruby會把current object記錄到 
  code
    | self
  | 之中。如果呼叫一個method但不指定receiver的話，預設就會把self當做receiver。當你呼叫method時指定了receiver，則self會在呼叫時method切換到對應的receiver。

h3 Private Method
p 
  | 在ruby中，private method指的是不能使用receiver呼叫的method，即使是self也不行。這樣的定義表示除了在物件本身之中呼叫外，其它的地方都無法呼叫這個method。
